##### 跨域

###### URL

```
URL：协议 + 域名 + 端口 + 参数
同源策略：浏览器的基本安全功能，两个页面的协议，域名，端口都相同认为是同源
```

###### JSONP

```javascript
<script>
    var script = document.createElement('script');
    script.type = 'text/javascript';
    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);

    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
 </script>
 //服务端
 handleCallback({"status": true, "user": "admin"})
```

###### postMessage

```javascript
//父
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>       
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            name: 'aym'
        };
        // 向domain2传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
    };

    // 接受domain2返回数据
    window.addEventListener('message', function(e) {
        alert('data from domain2 ---> ' + e.data);
    }, false);
</script>
//子
<script>
    // 接收domain1的数据
    window.addEventListener('message', function(e) {
        alert('data from domain1 ---> ' + e.data);

        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;

            // 处理后再发回domain1
            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');
        }
    }, false);
</script>
```

###### CORS

```javascript
服务端设置Access-Control-Allow-Origin

var xhr = new XMLHttpRequest()
xhr.withCredentials = true;
xhr.open('post', 'http://www.domain2.com:8080/login', true);
xhr.setRequestHeader('Content-Type', 'application/x-www=from-urlencoded');
xhr.send('user=admin')
xhr.onreadystatechange = function(){
    if(xhr.readyState == 4 && xhr.status == 200){
        alert(xhr.responseText)
    }
}
```



###### document.domain + iframe

```javascript
//父
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
    var user = 'admin';
</script>
//子
<script>
    document.domain = 'domain.com';
    // 获取父窗口中变量
    alert('get js data from parent ---> ' + window.parent.user);
</script>
```

##### TCP三次握手

1. 客户端发送TCP报文，标记位 SYN(请求建立连接)，序号Seq = X ，客户端进入SYN-SENT阶段

2. 服务端收到报文，结束LISTEN阶段，向客户端发送报文，标志位 SYN和ACK(表示客户端的报文Seq有效同意建立连接) ，序号Seq = y 确认号 Ack = X + 1 ，服务器进入SYN-RCVD阶段

3. 客户端 收到报文，结束SYN-SENT阶段，发送报文，标志位 ACK(表示我收到了) ，序号Seq = X = 1,确认号Ack = Y + 1,随后进入ESTABLISHED阶段。 

   为了防止服务器端开启一些无用的连接增加服务器开销，以及防止已失效的连接报文段突然传回服务端，产生一些错误。

##### TCP四次挥手

1. 客户端发送报文 标记位 FIN(释放连接)，序号 Seq = U，客户端进入 FIN-WAIT-1

2. 服务端接收到客户端发送的报文，确认要结束连接，服务端结束 ESTABLISHED阶段，进入 CLOSE-WAIT状态，并发送TCP报文，标记位 ACK(表示接收到客户端消息)，序号Seq = V 确认号 Ack = U + 1，随后服务端开始准备释放连接

3. 服务端发送ACK确认报文后，经过CLOSED-WAIT做好了释放的准备，再次向客户端发送报文，

   标记位FIN，ACK(表示已经准备好释放连接)，序号Seq = W 确认号 Ack = U + 1，服务端结束	CLOSED-WAIT进入LAST-WAIT。

4. 客户端确认从服务端发出的TCP报文，确认服务端做好已经释放的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务端发送报文，标记位ACK，序号Seq = U + 1.确认号Ack = W + 1

   客户端在发送后进入2SML的TIME-WAIT阶段，如果服务端在1SML没收到客户端的确认报文，就会再次发送FIN报文，会再次发送确认报文，客户端在2SML内再次收到服务端的确认报文说明服务端没接收到自己的ACK报文，客户端会再次发送ACK报文。

##### HTTP缓存

- 强制缓存

   Expires  设置过期时间，如果超时再向服务端请求，不超时就直接从缓存读取(memory cash),

  这样会导致两个问题(0-浏览器和服务端时间不同步，时间太长会一直使用缓存；1-缓存过期不管有没有发生变化都会请求)

  针对服务端/客户端时间不同步，设置相对时间Cash-Control = 10秒，10秒内直接使用缓存

- 协商缓存

  浏览器每次请求文件，服务器都会返回文件和Last-Modified(最后修改时间)，当浏览器缓存文件过期，浏览器会带上If-Modified-Since(请求回来的Last-Modified)，服务器会比较两个时间，一致就使用缓存，不一致返回新的文件和Last-Modified(最后修改时间)。

  这样也有问题(0-Last-Modified修改的是GMT时间，只能精确到秒，如果在一秒内更新文件检测不到；1-服务器上文件被多次修改，但是内容没改动，也会重新下载)

- 返回文件的唯一标识ETag，当文件过期时，浏览器带上请求头 If-None-Match (返回的ETag)，服务器比较，一致就用缓存，不一致返回新的。

##### 浏览器存储数据

1. Cookie

   缺点：存储量小；影响性能(cookie会作为请求头发送)；只能存储字符串；不安全

2. web存储

   - localStorage
   - sessionStorage

3. indexedDB

   存储大量数据

